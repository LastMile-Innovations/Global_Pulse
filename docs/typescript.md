# ðŸ“˜ TypeScript Best Practices & Features Guide

**Goal:** Leverage TypeScript's features effectively to build robust, maintainable, performant, and type-safe code within the Global Pulse application stack. This guide synthesizes key concepts and practices demonstrated through various examples.

| Category                         | Best Practice / Feature                                                      | Implementation / Example (TypeScript Syntax)                                                                                                                                  | Rationale / Benefit (Focus on Safety, Clarity, Performance)                                                                                                                                                              |
| :------------------------------- | :--------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Core Types & Syntax**        | **Use Primitive Types Correctly**                                          | `let isDone: boolean = false;` <br> `let color: string = "blue";` <br> `let decimal: number = 6;` <br> `let big: bigint = 100n;` <br> `const sym = Symbol("key");`           | **Foundation:** Ensures basic type safety for common values. Use lowercase primitives (`string`, `number`) not boxed types (`String`, `Number`). `bigint` for large integers. `symbol` for unique identifiers.                  |
|                                  | **Leverage Type Inference**                                                  | `let myName = "Alice"; // Inferred as string`                                                                                                                                 | **Conciseness:** Reduces boilerplate when the type is obvious from initialization. TypeScript infers types automatically in many cases. Still add explicit types where clarity is needed or inference isn't possible/desired. |
|                                  | **Use Explicit Type Annotations for Clarity/Contracts**                      | `let myName: string = "Alice";` <br> `function greet(name: string) { ... }` <br> `function getNum(): number { return 26; }`                                               | **Clarity & Safety:** Makes intent explicit, improves readability, enforces contracts at function boundaries/variable declarations. Essential when inference isn't specific enough or for API definitions.                      |
|                                  | **Define Object Shapes (Interfaces, Type Aliases)**                          | `interface Person { name: string; age: number; }` <br> `type Point = { x: number; y: number };` <br> `function greet(person: Person) { ... }`                                    | **Structure & Safety:** Clearly defines the expected shape of objects, enabling static checking, catching typos (`obj.heigth`), and improving developer understanding. Choose interface vs type based on need (extension vs. utility). |
|                                  | **Use Union Types for Multiple Possibilities**                             | `type ID = number | string;` <br> `function printId(id: ID) { ... }` <br> `type Status = "pending" | "success" | "error";`                                                     | **Flexibility & Safety:** Allows a variable or parameter to hold values of several specific types, enhancing flexibility while maintaining type safety over `any`. Requires narrowing to access type-specific members.      |
|                                  | **Use Literal Types for Specific Values**                                    | `type Alignment = "left" | "right" | "center";` <br> `function configure(x: Options | "auto") { ... }` <br> `type Result = -1 | 0 | 1;`                             | **Precision & Safety:** Constrains values to specific strings, numbers, or booleans, acting like enums. Prevents invalid value assignments at compile time. Great for status flags, configuration options.              |
|                                  | **Use Array and Tuple Types**                                                | `let list: number[] = [1, 2, 3];` <br> `let list2: Array<number> = [1, 2, 3];` <br> `type StringNumPair = [string, number];` <br> `let x: StringNumPair = ["hello", 10];` | **Structure for Collections:** `Array<T>` or `T[]` for homogenous lists. Tuples `[T, U]` for fixed-size arrays with specific types at specific indices, ensuring order and type correctness. Supports optional/rest elements. |
|                                  | **Use `readonly` Modifier for Immutability**                               | `interface Point { readonly x: number; }` <br> `let ro: ReadonlyArray<number> = a;` <br> `class Octopus { constructor(readonly name: string) {} }`                            | **Safety & Predictability:** Prevents accidental modification of properties/arrays after creation. Improves predictability, especially when passing objects/arrays around. Use `Readonly<T>` utility type.                |
|                                  | **Use Optional Properties (`?`)**                                           | `interface SquareConfig { color?: string; width?: number; }` <br> `function printName(obj: { first: string; last?: string }) { ... }`                                     | **Flexibility:** Allows properties to be absent from an object. Essential for option bags or partially filled objects. Requires checking for `undefined` before use (if `strictNullChecks` enabled).                   |
|                                  | **Avoid `any` Type**                                                         | `let obj: any = { x: 0 }; obj.foo(); // No compile error`                                                                                                                  | **CRITICAL for Safety:** `any` opts out of type checking entirely, sacrificing safety for flexibility. Leads to potential runtime errors. Use `unknown` instead if the type is truly unknown.                          |
|                                  | **Use `unknown` for Unpredictable Types**                                  | `let notSure: unknown = 4; if (typeof notSure === "string") { console.log(notSure.toUpperCase()); }`                                                                    | **Safety:** Safer alternative to `any`. Represents a value whose type isn't known. Requires type checking (narrowing) before operations can be performed, preventing unsafe assumptions.                               |
|                                  | **Use `never` for Unreachable Code/Exhaustiveness**                          | `function fail(msg: string): never { throw new Error(msg); }` <br> `function infiniteLoop(): never { while (true) {} }` <br> `const _check: never = shape; // Exhaustiveness` | **Correctness & Safety:** Represents values that should never occur. Useful for exhaustiveness checks in switch statements (ensuring all cases are handled) and functions that never return normally.                    |
|                                  | **Use `void` for Functions Without Return Values**                           | `function warnUser(): void { console.log("Warning"); }` <br> `type Callback = () => void;`                                                                               | **Clarity & Safety:** Explicitly indicates a function doesn't return a meaningful value. In callbacks, prevents accidental use of potentially undefined return values.                                                 |
| **Type Safety & Checking**       | **CRITICAL: Enable `strict` Mode (or individual flags)**                   | `tsconfig.json`: `"strict": true` (enables `noImplicitAny`, `strictNullChecks`, `strictFunctionTypes`, `strictBindCallApply`, `strictPropertyInitialization`, `noImplicitThis`, `useUnknownInCatchVariables`) | **Maximum Safety:** Enables all strict type-checking options, catching a wide range of potential errors at compile time. Significantly improves code quality and reduces runtime bugs. Highly recommended.          |
|                                  | **Enable `noImplicitAny`**                                                   | `function fn(s) { console.log(s.subtr(3)); } // Error if noImplicitAny: true`                                                                                             | **Safety:** Requires explicit type annotations when TypeScript cannot infer a type, preventing accidental `any` types which bypass type checking.                                                                     |
|                                  | **Enable `strictNullChecks`**                                              | `let x: number; x = null; // Error if strictNullChecks: true` <br> `function greet(name: string | null) { if (name) { console.log(name.toUpperCase()); } }`              | **Safety:** Prevents errors caused by `null` and `undefined` values. Requires explicit handling of potential null/undefined values using checks or non-null assertions (`!`).                                          |
|                                  | **Enable `strictFunctionTypes`**                                           | `let fn1: (x: Animal) => void; let fn2: (x: Dog) => void; fn1 = fn2; // Error if strictFunctionTypes: true`                                                              | **Safety (Contravariance):** Ensures function parameter types are checked contravariantly, preventing unsafe assignments where a function expects a broader type but gets one requiring a narrower type. Methods are bivariant. |
|                                  | **Enable `strictPropertyInitialization`**                                  | `class BadGreeter { name: string; } // Error if strictPropertyInitialization: true` <br> `class Good { name: string = "hello"; } // OK`                                  | **Safety:** Ensures class properties declared with a type are initialized in the constructor or have a default value, preventing errors from accessing uninitialized properties. Use `!` assertion if needed carefully.      |
|                                  | **Enable `noImplicitThis`**                                                  | `function fn() { console.log(this.name); } // Error if noImplicitThis: true` <br> `function fn(this: MyType) { ... }`                                                   | **Safety:** Prevents errors from `this` having an unexpected context (often `undefined` in strict mode or `window`). Requires explicit `this` parameter annotations.                                                     |
|                                  | **Enable `useUnknownInCatchVariables`**                                    | `try {} catch (err: unknown) { if (err instanceof Error) { console.log(err.message); } }`                                                                              | **Safety:** Catches errors have `unknown` type instead of `any`, forcing type checks before accessing properties like `message`, preventing runtime errors if a non-Error is thrown.                               |
|                                  | **Use Type Assertions (`as`, `<>`) Sparingly**                            | `const myCanvas = document.getElementById("main") as HTMLCanvasElement;` <br> `let len = (<string>val).length;`                                                           | **Flexibility (Use Cautiously):** Overrides TypeScript's inferred type when you know better. **Unsafe:** Bypasses type checking; can lead to runtime errors if the assertion is wrong. Use `as` syntax in `.tsx` files. |
|                                  | **Use Non-Null Assertion Operator (`!`) Cautiously**                       | `function liveDangerously(x?: number | null) { console.log(x!.toFixed()); }`                                                                                              | **Convenience (Use Cautiously):** Tells the compiler a value cannot be `null` or `undefined`. **Unsafe:** Bypasses `strictNullChecks`; can lead to runtime errors if the value *is* null/undefined.                    |
|                                  | **Leverage Control Flow Analysis (Narrowing)**                             | `function pad(p: number | string) { if (typeof p === "number") { return " ".repeat(p); /* p is number */ } return p; /* p is string */ }` <br> `if ("swim" in pet) { pet.swim(); /* pet is Fish */ }` | **Safety & Ergonomics:** TypeScript analyzes code flow (`if`, `switch`, `typeof`, `instanceof`, `in`, truthiness) to narrow types within blocks, allowing safe access to type-specific members without assertions.         |
|                                  | **Use Type Predicates (User-Defined Type Guards)**                         | `function isFish(pet: Fish | Bird): pet is Fish { return (pet as Fish).swim !== undefined; } if (isFish(pet)) { pet.swim(); }`                                            | **Custom Narrowing Logic:** Allows creating reusable functions that perform runtime checks and signal narrowed types to the compiler using the `param is Type` return signature.                                     |
|                                  | **Use `satisfies` Operator (TS 4.9+)**                                     | `const palette = { red: [255,0,0], green: "#00ff00" } satisfies Record<string, string | RGB>; const greenNorm = palette.green.toUpperCase();`                             | **Validation without Widening:** Ensures an expression matches a type *without* changing the expression's inferred type. Catches errors while preserving specific literal/property types for later use.                 |
|                                  | **Use `asserts` for Assertion Functions**                                  | `function assertIsString(val: any): asserts val is string { if (typeof val !== "string") throw new Error(); } let x: unknown; assertIsString(x); x.toUpperCase(); // OK` | **Type Guarding via Exceptions:** Defines functions that check conditions and throw errors if they fail. TypeScript understands these functions narrow types in the remaining code path.                               |
|                                  | **Understand Excess Property Checks**                                      | `let sq = createSquare({ colour: "red", width: 100 }); // Error: 'colour' does not exist` <br> `let opts = { colour: "red" }; createSquare(opts); // OK (bypassed)`      | **Safety (Object Literals):** Catches typos or extra properties when assigning object *literals* directly to typed variables or parameters. Bypassed if assigned to an intermediate variable.                               |
| **Functions**                    | **Define Clear Function Signatures**                                       | `function greet(name: string, date: Date): void { ... }`                                                                                                              | **Clarity & Safety:** Explicit parameter and return type annotations make function contracts clear and enforce type safety at boundaries.                                                                           |
|                                  | **Use Optional Parameters (`?`) and Default Values**                       | `function f(x?: number) { ... }` <br> `function build(f: string, l = "Smith") { ... }` <br> `function f({ a = "", b = 0 } = {}): void { ... }`                          | **Flexibility:** Allows omitting arguments or providing defaults. Use `?` for optionality. Default values also make parameters optional. Handle defaults correctly in destructuring.                                  |
|                                  | **Use Rest Parameters (`...`)**                                              | `function multiply(n: number, ...m: number[]) { return m.map(x => n * x); }`                                                                                           | **Flexibility:** Allows functions to accept an arbitrary number of arguments of a specific type as an array. Must be the last parameter.                                                                              |
|                                  | **Use Function Overloads for Varying Signatures**                          | `function makeDate(ts: number): Date; function makeDate(m: number, d: number, y: number): Date; function makeDate(mOrTs: number, d?: number, y?: number): Date { ... }`      | **Precision:** Provides multiple specific call signatures for a single implementation function. TypeScript resolves to the *first* matching overload. Use cautiously; prefer unions/optionals if simpler.               |
|                                  | **Use `this` Parameter for Context Typing**                                | `function fn(this: SomeType, x: number) { ... }` <br> `interface DB { filter(this: User): boolean; }`                                                                   | **Safety (`noImplicitThis`):** Explicitly defines the expected type of `this` within a function, preventing errors from incorrect context. The `this` parameter is erased during compilation. Use `this: void` for standalone functions. |
|                                  | **Understand `void` Return Type Behavior**                                 | `type voidFunc = () => void; const f1: voidFunc = () => true; // OK` <br> `function f2(): void { return true; // Error if explicit }`                                        | **Callback Safety:** Contextually typed `void` return allows returning any value (it's ignored). Explicit `void` return type *requires* no return value (or `return;` / `return undefined;`).                          |
|                                  | **Use Arrow Functions for Lexical `this`**                                 | `class Handler { onClick = (e: Event) => { this.info = e.message; } }`                                                                                                   | **Context Preservation:** Arrow functions capture `this` from their surrounding context, avoiding the need for `.bind()` or `self = this` workarounds, especially in callbacks and event handlers.                      |
|                                  | **Prefer Function Type Expressions or Aliases**                            | `function greeter(fn: (a: string) => void) { ... }` <br> `type GreetFunc = (a: string) => void; function greeter(fn: GreetFunc) { ... }`                               | **Readability:** Provides concise and clear syntax for defining function types, especially for callbacks or complex signatures. Aliases improve reusability.                                                       |
| **Classes**                      | **Use `class` Syntax for OOP**                                             | `class Point { x: number = 0; y: number = 0; constructor(x=0, y=0) { this.x=x; this.y=y; } scale(n: number): void { ... } }`                                              | **Structure & Encapsulation:** Provides standard OOP features like constructors, fields, methods, inheritance.                                                                                                    |
|                                  | **Use Access Modifiers (`public`, `protected`, `private`)**                | `public greet() { ... }` (default) <br> `protected getName() { ... }` <br> `private x = 0;`                                                                              | **Encapsulation:** Controls member visibility. `public` (anywhere), `protected` (class & subclasses), `private` (only within the class). TypeScript's `private` is compile-time only.                                |
|                                  | **Use `#private` Fields (ECMAScript Private)**                             | `class Person { #name: string; constructor(name: string) { this.#name = name; } }`                                                                                     | **True Runtime Privacy:** Provides hard privacy enforced by the JavaScript runtime, preventing access from outside the class. Preferred over TypeScript `private` for strong encapsulation.                           |
|                                  | **Use `readonly` Modifier for Immutable Fields**                           | `class Greeter { readonly name: string = "world"; constructor(o?: string) { if(o) this.name = o; } }`                                                                    | **Immutability:** Prevents modification of a field after initialization (in constructor or at declaration).                                                                                                      |
|                                  | **Use Parameter Properties**                                                 | `class Params { constructor(public readonly x: number, protected y: number, private z: number) {} }`                                                                   | **Conciseness:** Shorthand syntax to declare and initialize class members directly from constructor parameters.                                                                                                   |
|                                  | **Understand `this` in Methods**                                           | `class C { x="hello"; m() { this.x = "world"; } }` <br> Use arrow functions for methods used as callbacks: `getName = () => { return this.name; }`                           | **Context:** `this` in methods typically refers to the class instance. Beware of losing context when passing methods as callbacks; use arrow functions or `.bind()`.                                                  |
|                                  | **Use `static` Members for Class-Level Properties/Methods**                | `class Grid { static origin = {x:0, y:0}; static distance(p1, p2) { ... } } Grid.origin; Grid.distance(p1, p2);`                                                      | **Utility & State:** Defines members belonging to the class itself, not instances. Useful for constants, factory methods, utility functions related to the class.                                                      |
|                                  | **Use `super` for Base Class Access**                                      | `class Derived extends Base { constructor() { super(); } greet(n?: string) { if (!n) super.greet(); else ... } }`                                                        | **Inheritance:** Allows derived classes to call base class constructor and methods. `super()` *must* be called in derived constructor before accessing `this`.                                                      |
|                                  | **Use `abstract` Classes for Base Templates**                              | `abstract class Base { abstract getName(): string; printName() { console.log(this.getName()); } } class Derived extends Base { getName() { return "world"; } }`             | **Contracts & Templates:** Defines base classes that cannot be instantiated directly and may contain abstract members that *must* be implemented by derived classes. Enforces a common structure.                        |
|                                  | **Implement Interfaces (`implements`)**                                    | `interface Pingable { ping(): void; } class Sonar implements Pingable { ping() { console.log("ping"); } }`                                                               | **Contract Enforcement:** Ensures a class adheres to the structure defined by an interface. Checks instance side only.                                                                                              |
|                                  | **Use `this` Type for Fluent Interfaces/Subclass Safety**                  | `class Builder { set(v: string): this { this.value = v; return this; } } class Clearable extends Builder { clear(): void {} } new Clearable().set("a").clear(); // OK`        | **Polymorphism:** `this` type dynamically refers to the current class or subclass type, enabling method chaining that correctly returns the derived type instance.                                                        |
|                                  | **Understand Structural Typing Compatibility**                             | `class Point1 { x=0; y=0; } class Point2 { x=0; y=0; } const p: Point1 = new Point2(); // OK`                                                                         | **Flexibility:** Classes are compatible if their *instance* structures match, regardless of explicit inheritance or implementation clauses. Static side and constructors are not checked for compatibility.                |
| **Generics**                     | **Use Generics for Reusable, Type-Safe Components**                        | `function identity<T>(arg: T): T { return arg; }` <br> `class Box<T> { contents: T; }` <br> `interface Backpack<T> { add: (obj: T) => void; }`                           | **Flexibility & Safety:** Creates components (functions, classes, interfaces, type aliases) that can work with various types while maintaining type safety and relationships between inputs and outputs.                    |
|                                  | **Use Type Parameter Constraints (`extends`)**                             | `function loggingIdentity<T extends Lengthwise>(arg: T): T { console.log(arg.length); return arg; }`                                                                    | **Restricting Types:** Ensures generic type parameters meet certain requirements (e.g., have specific properties or methods), allowing safe access to those members within the generic component.                     |
|                                  | **Use Type Parameters in Constraints**                                     | `function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] { return obj[key]; }`                                                                               | **Relational Constraints:** Constrains one type parameter based on another (e.g., ensuring a key K is actually a key of object T). Enables advanced type-safe patterns.                                               |
|                                  | **Specify Type Arguments Explicitly When Needed**                          | `let output = identity<string>("myString");` <br> `const arr = combine<string | number>([1], ["hello"]);`                                                              | **Guidance:** Manually provides types when inference fails or when a broader type is desired than what TypeScript would infer automatically.                                                                      |
|                                  | **Use Generic Defaults**                                                   | `declare function create<T extends HTMLElement = HTMLDivElement>(): Container<T>; create(); // Container<HTMLDivElement>`                                                 | **Convenience:** Provides a default type for a generic parameter if none is supplied. Simplifies common usage patterns.                                                                                           |
| **Advanced Types**               | **Use Mapped Types for Transformations**                                   | `type Partial<T> = { [P in keyof T]?: T[P] };` <br> `type Readonly<T> = { readonly [P in keyof T]: T[P] };` <br> `type OptionsFlags<T> = { [P in keyof T]: boolean; };`      | **Metaprogramming:** Creates new types by transforming properties of existing types (making optional, readonly, changing types). Reduces boilerplate for related type variations. Supports modifiers (`+`/`-`).           |
|                                  | **Use Key Remapping in Mapped Types (`as`)**                               | `type Getters<T> = { [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]; };` <br> `type RemoveKind<T> = { [P in keyof T as Exclude<P, "kind">]: T[P]; };`       | **Advanced Transformations:** Allows renaming or filtering keys during mapped type creation. Enables powerful type manipulations like creating getter types or removing specific properties.                             |
|                                  | **Use Conditional Types (`extends ? :`)**                                  | `T extends U ? X : Y` <br> `type IsArray<T> = T extends any[] ? true : false;` <br> `type TypeName<T> = T extends string ? "string" : ...;`                            | **Type Logic:** Selects one of two types based on a type relationship check (`extends`). Enables creating types based on conditions, filtering unions, and complex type logic. Distributes over naked type parameters. |
|                                  | **Use `infer` Keyword in Conditional Types**                               | `type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;` <br> `type Unpacked<T> = T extends (infer U)[] ? U : ...;`                                       | **Type Extraction:** Declares type variables *within* a conditional type's `extends` clause to capture inferred types (e.g., function return types, array element types, promise resolved types).                       |
|                                  | **Use `keyof` Type Operator**                                              | `type Point = { x: number; y: number }; type P = keyof Point; // "x" | "y"`                                                                                               | **Property Name Extraction:** Creates a union type of the known public property names of a type. Useful for constraining generic property access. Returns `string | number` for types with string/number index signatures. |
|                                  | **Use `typeof` Type Operator**                                             | `let s = "hello"; let n: typeof s; // string` <br> `type Predicate = (x: unknown) => boolean; type K = ReturnType<typeof document.createElement>; // HTMLElement`        | **Value Type Extraction:** Obtains the type of a *value* (variable or property). Useful for deriving types from existing values or constants without redefining them.                                                  |
|                                  | **Use Indexed Access Types (`T[K]`)**                                      | `type Person = { age: number; name: string; }; type Age = Person["age"]; // number` <br> `type K = keyof Person; type PropType = Person[K]; // string | number`          | **Property Type Lookup:** Accesses the type of a specific property `K` on a type `T`. Can use literal types or unions of literal types for `K`.                                                                  |
|                                  | **Use Template Literal Types**                                             | ``type Greeting = `hello ${World}`;`` <br> ``type EventName<T> = `${string & keyof T}Changed`;`` <br> ``type Cases<T extends string> = `${Uppercase<T>} ${Lowercase<T>}`;`` | **String Manipulation at Type Level:** Creates complex string literal types by concatenating/manipulating other types. Useful for event names, CSS-in-JS keys, API routes. Supports `Uppercase`, `Lowercase`, etc.          |
|                                  | **Use Intersection Types (`&`)**                                           | `type ColorfulCircle = Colorful & Circle;` <br> `function draw(cc: ColorfulCircle) { console.log(cc.color, cc.radius); }`                                               | **Combining Types:** Creates a new type that has *all* members of the combined types. Useful for mixins or combining interfaces. Merges properties; conflicting primitive types become `never`.                       |
|                                  | **Use Discriminated Unions**                                               | `type Shape = { kind: "circle"; r: number } | { kind: "square"; size: number }; function area(s: Shape) { switch (s.kind) { case "circle": return PI*s.r**2; ... } }` | **Safe Union Handling:** Pattern using a common literal property (`kind`) to reliably narrow union types in `switch` or `if` statements. Provides excellent type safety and exhaustiveness checking (`never`).          |
| **Modules & Namespaces**         | **Use ES Modules (`import`/`export`)**                                     | `export const pi = 3.14; import { pi } from "./math";` <br> `export default class X {} import X from "./X";`                                                              | **Standard & Tree-Shakable:** The standard JavaScript module system. Allows static analysis, tree-shaking for smaller bundles, and clear dependency management. Prefer over namespaces for organizing code.              |
|                                  | **Use Type-Only Imports/Exports (`import type`, `export type`)**           | `import type { MyType } from "./types"; export type { MyInterface };`                                                                                                  | **Clarity & Safety:** Explicitly marks imports/exports that are only used for type annotations and should be erased during compilation. Essential with `isolatedModules` or `verbatimModuleSyntax`.                     |
|                                  | **Use `verbatimModuleSyntax` for Predictable Emit**                        | `tsconfig.json`: `"verbatimModuleSyntax": true`                                                                                                                       | **Predictable Emit:** Ensures imports/exports are emitted exactly as written (unless marked `type`), avoiding surprising elision behavior. Supersedes older flags like `preserveValueImports`. Recommended for new code. |
|                                  | **Configure Module Resolution (`moduleResolution`)**                       | `tsconfig.json`: `"moduleResolution": "bundler"` (for modern bundlers) or `"nodenext"` (for modern Node.js) or `"node16"` (older Node.js)                               | **Correct Imports:** Tells TypeScript how to find modules based on the target environment (Node.js vs. bundler). `bundler` is often best for web apps using Vite, Webpack etc.                                        |
|                                  | **Use `paths` and `baseUrl` for Non-Relative Imports (Carefully)**         | `tsconfig.json`: `"baseUrl": "./src", "paths": { "@lib/*": ["lib/*"] }`                                                                                               | **Convenience (Use Cautiously):** Allows cleaner import paths. **Requires matching runtime configuration** (e.g., bundler aliases) to avoid runtime errors. Can make code less portable.                                |
|                                  | **Use Namespaces for Global Scope Augmentation or Logical Grouping (Rarely)** | `declare global { interface String { fancyFormat(): string; } }` <br> `namespace Validation { export interface StringValidator { ... } }`                               | **Legacy/Global:** Primarily for augmenting global scope or organizing types in declaration files (.d.ts). Avoid for structuring application code; use modules instead. Merges declarations with the same name.       |
| **Configuration (`tsconfig.json`)** | **Use `tsconfig.json` for Project Settings**                               | Create `tsconfig.json` at project root. Use `tsc --init`.                                                                                                             | **Centralized Control:** Defines compiler options, files included/excluded, project references. Essential for managing TypeScript projects.                                                                       |
|                                  | **Use `extends` for Shared Configurations**                                | `tsconfig.json`: `"extends": "./base.tsconfig.json"`                                                                                                                  | **Maintainability:** Allows creating base configurations and extending them for specific parts of the project (e.g., server vs client, tests vs src), reducing duplication.                                           |
|                                  | **Use `include`, `exclude`, `files` to Specify Compilation Scope**         | `"include": ["src/**/*"]` <br> `"exclude": ["node_modules", "**/*.spec.ts"]` <br> `"files": ["core.ts", "utils.ts"]`                                                   | **Control:** Determines which files are included in the compilation. `include`/`exclude` use glob patterns. `files` lists specific files.                                                                            |
|                                  | **Use Project References (`references`) for Monorepos/Large Projects**     | `tsconfig.json`: `"references": [{ "path": "../shared" }, { "path": "./backend" }]` `package.json`: `"build": "tsc -b"`                                                  | **Performance & Structure:** Enables faster builds (`tsc -b`) by only rebuilding changed projects and their dependents. Improves code organization and separation of concerns. Requires `composite: true` in referenced projects. |
|                                  | **Configure Output (`outDir`, `rootDir`, `declaration`, `sourceMap`)**     | `"outDir": "./dist"` <br> `"declaration": true` <br> `"sourceMap": true`                                                                                             | **Build Control:** Controls where JavaScript output (`.js`), declaration files (`.d.ts`), and source maps (`.map`) are emitted. `rootDir` helps maintain source structure in output.                                |
| **JSDoc & JavaScript**         | **Leverage JSDoc for Types in JavaScript (`checkJs`)**                     | `// @ts-check` <br> `/** @type {number} */ var x;` <br> `/** @param {string} p1 */ function fn(p1) {}` <br> `/** @template T */ /** @param {T} x */ function id(x){}`       | **Gradual Typing:** Enables adding TypeScript type checking to existing JavaScript codebases using JSDoc comments without migrating to `.ts` files. Use `// @ts-check` per file.                                      |
|                                  | **Use `@satisfies` in JSDoc**                                              | `/** @satisfies {CompilerOptions} */ let opts = { outdir: "..." }; // Typo caught`                                                                                     | **JS Type Validation:** Provides `satisfies` behavior in JSDoc, allowing validation against a type without changing the inferred JavaScript type.                                                                |
| **Error Handling & Safety**    | **Use Exhaustiveness Checking with `never`**                               | `function assertNever(x: never): never { throw new Error(); } switch (shape.kind) { ... default: assertNever(shape); }`                                                | **Safety:** Ensures all possible cases (e.g., in a discriminated union) are handled in `switch` or `if/else` chains. Assigning to `never` causes a compile error if a case is missed.                                |
|                                  | **Prefer `unknown` over `any`**                                            | See `unknown` entry above.                                                                                                                                            | **Safety:** Forces type checks before use, unlike `any`.                                                                                                                                                         |
|                                  | **Use `noUncheckedIndexedAccess` for Safer Indexing**                      | `tsconfig.json`: `"noUncheckedIndexedAccess": true` <br> `let val = obj[key]; // Type is T | undefined`                                                                   | **Safety:** Adds `undefined` to the type of potentially non-existent properties accessed via index signatures (`obj[key]`) or array indices, forcing checks.                                                      |
|                                  | **Use `noPropertyAccessFromIndexSignature` for Stricter Access**         | `tsconfig.json`: `"noPropertyAccessFromIndexSignature": true` <br> `settings.username; // Error` <br> `settings["username"]; // OK`                                        | **Clarity & Safety:** Requires using bracket notation (`obj["prop"]`) instead of dot notation (`obj.prop`) for properties defined only by an index signature, making intent clearer.                               |
| **Asynchronous Code**            | **Use `async`/`await` for Promises**                                       | `async function fetchData(): Promise<Data> { const response = await fetch(...); return await response.json(); }`                                                       | **Readability & Simplicity:** Provides synchronous-looking syntax for working with Promises, improving code readability and maintainability compared to `.then()` chains.                                            |
|                                  | **Use `Promise<T>` Type**                                                  | `function delay(ms: number): Promise<void> { ... }`                                                                                                                   | **Clarity:** Explicitly types asynchronous operations that return Promises, indicating the type of the resolved value (`T`).                                                                                          |
|                                  | **Use `Awaited<T>` Utility Type**                                          | `type Result = Awaited<Promise<string>>; // string` <br> `type Nested = Awaited<Promise<Promise<number>>>; // number`                                                    | **Promise Unwrapping:** Recursively unwraps Promise types to get the final resolved value type. Useful in generic contexts or with complex Promise chains.                                                        |
| **Resource Management**          | **Use `using` and `await using` (TS 5.2+)**                                | `using file = new TempFile(".tmp");` <br> `await using tx = await DatabaseTransaction.create(db);` <br> `class MyResource implements Disposable { [Symbol.dispose]() {} }` | **Safety & Simplicity:** Provides declarative, block-scoped resource management. Automatically calls `[Symbol.dispose]` (sync) or `[Symbol.asyncDispose]` (async) when exiting the scope, ensuring cleanup even with errors. |

---

**TypeScript Strategy Summary:**

TypeScript is foundational to Global Pulse's goals of performance, safety, and maintainability.

1.  **Embrace Strictness:** Enable `strict` mode in `tsconfig.json` from the start. This catches the most common errors.
2.  **Type Everything (Almost):** Use explicit types for function signatures, complex objects, and where inference isn't clear. Leverage inference for simple variable initializations. **Avoid `any`**. Use `unknown` when necessary and narrow appropriately.
3.  **Model Data Accurately:** Use interfaces, type aliases, unions, literals, enums (`as const` objects preferred), and generics to precisely model application data structures and contracts.
4.  **Leverage the Type System:** Utilize mapped types, conditional types, `keyof`, `typeof`, and utility types (`Partial`, `Readonly`, `Required`, `Awaited`, etc.) to reduce boilerplate and create robust, flexible types.
5.  **Configure Correctly:** Set up `tsconfig.json` appropriately for the target environment (Node.js, bundler), enable safety checks, and configure module resolution and output settings.
6.  **Use Modern Features:** Employ recent additions like `satisfies`, `using`/`await using`, `#private` fields, and improved inference where applicable.
7.  **Integrate with JavaScript:** Use JSDoc (`@ts-check`, `@type`, `@param`, `@template`, `@satisfies`) for gradual typing or integrating with JavaScript codebases.

By consistently applying these practices, the codebase becomes more predictable, easier to refactor, less prone to runtime errors, and benefits from improved tooling and developer experience.
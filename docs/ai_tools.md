

**ðŸš€ Ultimate AI Agent Tool Usage Guide (Next.js 15 + React 19 + Drizzle + Supabase + Redis + AI SDK) ðŸš€**

**Goal:** Effectively design, implement, and optimize tools for your AI Agent to enable reliable interaction with external systems (databases, APIs), internal logic, and user interfaces, ensuring security, performance, and a seamless conversational flow.

| Category                                      | Best Practice                                                                    | Implementation Details / Example (AI SDK Tool Context)                                                                                                                                                                                                                                                                 | Rationale / Benefit (Focus on Tools)                                                                                                                                                                                                                                                                                                                         | Synergy / Integration Notes                                                                                                                                                                                                                                                                                                                                  |
| :-------------------------------------------- | :----------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Tool Definition (AI SDK Core)**             | **Use `tool()` Helper for Type Safety**                                      | `import { tool } from 'ai'; const myTool = tool({ description: '...', parameters: z.object({...}), execute: async (args) => {...} });`. Use specific types (`zodSchema`, `jsonSchema`) if needed.                                                                                                                    | **Type Safety & Inference:** Ensures `execute` function arguments match `parameters` schema. Provides strong typing for tool calls and results throughout the application. Simplifies definition.                                                                                                                                            | Define tools server-side in **Next.js** (e.g., `lib/tools.ts`). Parameters often validated using **Zod/Valibot** schemas, potentially generated from **Drizzle** schema (`drizzle-zod`).                                                                                                      |
|                                               | **Write Clear & Concise Tool `description`**                                 | Describe *what the tool does* and *when the LLM should use it* accurately and concisely. e.g., `'Fetches current weather for a specific city.'`, `'Use this to get the user location ONLY AFTER asking for confirmation.'`.                                                                                                     | **Crucial for LLM Selection:** The description is the primary information the LLM uses to decide which tool to call (if any). Good descriptions significantly improve the agent's reliability and prevent incorrect tool usage.                                                                                                            | Guides the **AI SDK Core** function (`streamText`/`generateText`) in selecting the correct tool based on the conversational context.                                                                                                                                                             |
|                                               | **Define Precise `parameters` Schema (Zod/Valibot)**                         | Use Zod (preferred) or Valibot/JSON Schema to define expected arguments accurately. Use `.describe()` on schema properties for extra LLM hints. `z.string().describe('The city name, e.g., San Francisco')`. Generate from Drizzle schema if applicable. | **Ensures Correct Arguments & Enables Validation:** Provides structure for LLM arguments. Allows AI SDK and your code to validate arguments before execution. `.describe()` provides crucial context to the LLM for filling parameters correctly.                                                                                         | Schemas generated via `drizzle-zod`/`drizzle-valibot` ensure consistency with your **Drizzle/Supabase** database structure. Schemas are used by **AI SDK Core** to validate LLM output and pass typed args to `execute`. Validated in **Next.js** backend before execution.                                  |
|                                               | **Implement Server-Side `execute` for Secure/Backend Operations**            | Define `async execute(args)` function within the `tool()` definition for tools interacting with DBs, internal APIs, secrets, or performing sensitive actions.                                                                                                     | **Security & Capability:** Keeps sensitive logic, credentials (**Supabase Vault**), and DB/API interactions securely on the server. Allows tools to perform complex backend tasks unavailable to the client.                                                                                                                           | `execute` runs within **Next.js Server Actions** or **API Routes**. Uses **Drizzle** client for **Supabase** DB access, `fetch` for internal/external APIs, **Redis** client for caching/state. Requires auth checks. |
|                                               | **Omit `execute` for Client-Handled Tools/Confirmations**                  | For tools meant to be handled entirely client-side (e.g., triggering UI changes, asking user confirmation, accessing browser APIs), define the tool *without* an `execute` function.                                                                       | **Signals Client Responsibility:** Indicates that the tool's logic or user interaction needs to happen in the frontend, managed by `useChat`. Prevents accidental server-side execution attempts.                                                                                                                                      | `streamText` in **Next.js** backend forwards these tool calls to **React** `useChat`. UI renders confirmation prompt or `onToolCall` hook handles execution client-side.                                           |
|                                               | **Design Tools for LLM Usability**                                         | Keep tools focused on single, well-defined tasks. Avoid overly complex parameter structures if possible. Ensure tool names and descriptions are unambiguous.                                                                                              | **Improves Reliability:** Simpler, focused tools are easier for the LLM to understand and use correctly. Complex tools increase the chance of incorrect parameter generation or selection errors.                                                                                                                                   | Test tool usage thoroughly with the chosen LLM via **AI SDK Core** functions. Iterate on descriptions and parameter schemas based on observed LLM behavior.                                                          |
| **Tool Invocation (LLM + AI SDK Core)**       | **Guide LLM via Prompt Engineering**                                       | Include instructions in the system prompt about available tools and *when* to use them. Provide examples if necessary. Emphasize thinking steps before calling tools if using ReAct patterns.                                                            | **Improves Tool Selection Accuracy:** Helps the LLM understand the context and purpose of each tool, leading to more appropriate and timely tool calls. Reduces hallucinated tool calls.                                                                                                                                             | System prompts are passed to **AI SDK Core** `streamText`/`generateText` alongside messages and tool definitions.                                                                                               |
|                                               | **Use `toolChoice` to Guide/Force Tool Use Strategically**                   | Use `toolChoice: 'required'` or `toolChoice: { type: 'tool', toolName: 'specificTool' }` in `streamText`/`generateText` when the agent *must* use a tool or a specific tool for a given step. Use `toolChoice: 'none'` to prevent tool use. | **Increases Reliability for Specific Tasks:** Overrides LLM's decision-making when a tool is definitely needed (or definitely not needed). Ensures critical steps involving specific tools are executed.                                                                                                                            | Apply within **Next.js** agent logic for specific steps where tool usage is mandatory (e.g., "You must get the weather before answering") or forbidden.                                                          |
|                                               | **Enable Multi-Step Calls (`maxSteps`)**                                   | Set `maxSteps > 1` in `streamText`/`generateText` to allow the AI SDK to automatically handle the loop of Tool Call -> Execute -> Result -> LLM Call.                                                                                 | **Enables Agentic Behavior:** Necessary for tasks requiring sequential tool use or reasoning based on tool results. AI SDK manages the orchestration loop.                                                                      | **Essential** for most agentic workflows involving tools. Configure in **AI SDK Core** call within **Next.js** backend.                                                                                         |
| **Tool Execution (Server-Side - Next.js)**    | **CRITICAL: Authorize Within `execute`**                                   | **Inside server-side `execute`:** Re-check user authentication (`supabase.auth.getUser()`) and authorization (e.g., check ownership via **Drizzle** `where` clause) before performing sensitive actions or accessing user data.       | **Security:** Tool execution might be triggered with valid-looking but potentially unauthorized arguments. Verifying auth within `execute` ensures the specific user context is allowed to perform the requested action via the tool.                                                                                               | **Mandatory** for any server-side `execute` function accessing user-specific data or performing restricted actions via **Drizzle/Supabase** or internal APIs.                                                    |
|                                               | **CRITICAL: Validate Arguments Within `execute` (Redundant but Safe)**       | Although AI SDK validates against schema before calling `execute`, consider re-validating critical/complex arguments inside `execute` using the same Zod/Valibot schema, especially if `execute` is complex or calls other services. | **Defense-in-Depth:** Provides an extra layer of validation security within the tool's execution context, protecting against potential (though unlikely) bypasses or internal logic errors before critical operations (e.g., DB writes).                                                                                              | Recommended for high-security tools or tools performing irreversible actions. Use schemas generated via `drizzle-zod`/`drizzle-valibot`.                                                                          |
|                                               | **Ensure `execute` is Performant & Non-Blocking**                          | Optimize DB queries (**Drizzle** + **Supabase** indexing). Cache results of deterministic/expensive calls (**Redis**). Use async/await correctly. Avoid synchronous blocking operations. Forward `abortSignal` to nested calls.           | **Agent Responsiveness:** Slow `execute` functions block the entire agent loop (`maxSteps`), significantly degrading perceived performance and user experience. Caching avoids redundant work. Async ensures server remains responsive.                                                                                             | Optimize **Drizzle** queries. Use **Redis** (`GET`/`SETEX`) for caching tool results (keyed by args?). Profile `execute` functions. Handle potential timeouts using `abortSignal`.                                 |
|                                               | **Handle `execute` Errors Gracefully**                                     | Wrap `execute` logic in `try...catch`. Log errors (Sentry). Return a meaningful, serializable error object or throw a `ToolExecutionError` with context.                                                                         | **Reliability & Debugging:** Prevents tool failures from crashing the agent. Allows AI SDK/LLM to potentially handle the error (if `maxSteps > 1`) or provides clear feedback to the user/logs.                                                                                                                                  | Catch **Drizzle** errors, API errors, etc. within `execute`. Throw `ToolExecutionError` for AI SDK handling or return structured error data. Log detailed errors server-side in **Next.js**.                   |
|                                               | **Return Serializable Results from `execute`**                             | Ensure the return value of `execute` is JSON-serializable (primitives, objects, arrays). Avoid returning complex class instances, functions, or non-serializable types.                                                         | **Compatibility:** The tool result needs to be serialized and sent back to the LLM (as part of the messages) and potentially streamed to the client UI. Non-serializable data will cause errors.                                                                                                                                      | Return data fetched via **Drizzle**, simple status messages, or data from external APIs.                                                                                                                       |
| **Tool Execution (Client-Side - React `useChat`)** | **Use `onToolCall` for Automatic Client Tools**                            | Implement `async onToolCall({ toolCall }) { if (toolCall.toolName === 'getClientLocation') { const location = await navigator.geolocation...; return location; } }` option in `useChat`.                                | **Enables Client-Side Automation:** Allows the agent to leverage browser APIs (`geolocation`, `localStorage`) or trigger simple, non-sensitive client logic automatically without user interaction.                                                                                                                                 | Use in **React** `useChat` hook for trusted client-side actions. Avoid sensitive operations. Result is automatically sent back via `useChat`.                                                               |
|                                               | **Security Risks of Client-Side Execution**                                | Be extremely cautious about what logic runs in `onToolCall`. Avoid any actions that could manipulate sensitive data or perform destructive operations, as client-side code can be inspected/manipulated.                               | **Security:** Client-side execution is inherently less secure than server-side execution. Malicious users could potentially trigger or modify client-side tool calls.                                                               | Prefer server-side `execute` for anything involving authentication, database writes (**Drizzle**), payments, or sensitive API calls. Use `onToolCall` only for safe browser API access or UI logic.             |
| **Tool UI & User Interaction (React `useChat`)** | **Render `tool-invocation` Parts Clearly**                                 | In **React**, map `message.parts`. Render UI based on `part.toolInvocation.state`: `'partial-call'` (streaming args), `'call'` (loading/pending execution), `'result'` (display formatted result). Use `toolCallStreaming` server-side. | **Visual Feedback & Transparency:** Shows the user the agent's "actions" â€“ which tool is being called, its arguments (potentially streamed), and its final result. Builds trust and understanding.                                                                                                                              | Essential rendering logic within the **React** component using `useChat`. Adapt UI based on `toolName` and `state`.                                                                                       |
|                                               | **Implement UI for Confirmation Tools**                                    | If `part.toolInvocation.toolName === 'askForConfirmation'`, render buttons/modal asking user to confirm/deny. Use `part.toolInvocation.args` to display the confirmation message.                                             | **Enables User Control:** Allows the agent to request explicit permission before performing potentially sensitive or irreversible client-side actions (e.g., accessing location, deleting data shown client-side).                                                                                                                | Render confirmation UI (buttons, modal) within the **React** component mapping `message.parts`. Trigger `addToolResult` on button click.                                                                       |
|                                               | **Use `addToolResult` to Provide Client Results**                            | Call `addToolResult({ toolCallId, result, ... })` from event handlers (e.g., confirmation button clicks) in the **React** component.                                                                                             | **Completes Client Tool Flow:** Sends the result (user confirmation, data from browser API) back to the `useChat` hook, which then sends it to the server to continue the agent loop (`maxSteps`).                                                                                                                            | Called from **React** event handlers attached to confirmation UI elements or after `onToolCall` logic completes (if needing manual steps).                                                                    |
| **Performance & Optimization**                    | **Optimize Tool `execute` Performance (DB/API/Cache)**                     | **Reiteration:** Fast tool execution is paramount. Optimize **Drizzle** queries (indexing!), cache external API calls/DB results in **Redis**, avoid blocking I/O.                                                                 | **Reduces Agent Latency:** Directly impacts the time taken for each agent step involving a server-side tool. Slow tools make the agent feel sluggish.                                                                         | Apply **Drizzle**, **Supabase**, **Redis** best practices within tool `execute` functions in **Next.js**.                                                                                                       |
|                                               | **Cache Deterministic Tool Results (Redis)**                               | **Inside `execute`:** Check **Redis** cache first using arguments as part of the key. If hit, return cached result. If miss, execute logic, store result in **Redis** (`SETEX`) before returning.                               | **Avoids Redundant Computation/API Calls:** Significantly speeds up repeated calls to the same tool with the same arguments (e.g., fetching static data, calling rate-limited APIs). Reduces cost and latency.                                                                                                               | Implement caching logic using **Upstash Redis** client within server-side `execute` functions in **Next.js**. Use a consistent keying strategy based on tool name and arguments. Use appropriate TTLs.        |
|                                               | **Stream Tool Calls (`toolCallStreaming: true`)**                            | Enable `toolCallStreaming: true` in `streamText` server-side. Handle `'partial-call'` state in UI.                                                                                                                      | **Improved Perceived Performance:** Shows tool activity sooner while the LLM generates arguments, making the agent feel more responsive.                                                                                  | Enable server-side in **Next.js** `streamText`. Requires UI handling in **React** `useChat` message rendering.                                                                                                |
|                                               | **Use Active Tools (`experimental_activeTools`) for Large Toolsets**         | Pass `experimental_activeTools: ['tool1', 'tool3']` to `streamText`/`generateText` to limit the tools the LLM considers for a specific call.                                                                            | **Performance & Focus:** Reduces token usage and potentially improves LLM focus by limiting the available tool choices to only relevant ones for the current step.                                                          | Useful for complex agents with many tools. Requires logic in **Next.js** backend to determine relevant tools for each step.                                                                              |
| **Error Handling (End-to-End)**                   | **Handle Tool-Specific Errors**                                          | Catch specific **AI SDK** errors (`NoSuchToolError`, `InvalidToolArgumentsError`, `ToolExecutionError`). Check `error.cause`. Provide specific feedback/retry logic based on error type.                                        | **Robust Recovery:** Allows distinguishing between LLM mistakes (bad args, wrong tool) and tool failures (`execute` error). Enables more targeted error messages or recovery strategies.                                   | Implement `try...catch` in `generateText` or use `onError`/`getErrorMessage` in `streamText` (**Next.js** backend) and `onError` in `useChat` (**React** client).                                             |
|                                               | **Surface Errors Clearly in UI**                                           | Use `useChat` `error` state and potentially custom data stream messages to inform the user about tool failures in a non-technical way. Offer retry options (`reload`) where appropriate.                                          | **User Experience:** Prevents user confusion when the agent gets stuck. Explains (briefly) what went wrong.                                                                                                                  | Map backend errors to user-friendly messages displayed in the **React** UI.                                                                                                                                  |
| **Testing**                                   | **Test Tools Independently**                                               | Write unit/integration tests specifically for server-side tool `execute` functions. Mock dependencies (**Drizzle**, **Redis**, external APIs).                                                                                 | **Ensures Tool Reliability:** Verifies that the core logic of each tool works correctly in isolation before integrating with the LLM.                                                                                     | Standard **Next.js** backend testing practices. Mock **Drizzle** client, **Redis** client.                                                                                                                    |
|                                               | **Test Agent Flow with Mock Tools**                                        | Use **AI SDK Mock Providers** (`MockLanguageModelV1`) in integration tests. Configure mocks to return specific tool calls and test how the agent logic handles them and the corresponding `execute` calls or client interactions. | **Verifies Orchestration Logic:** Tests the agent's ability to correctly interpret LLM output, trigger tools (mocked `execute`), handle results, and continue the flow without relying on actual LLM calls.                     | Use `ai/test` mocks in **Next.js** integration tests for Server Actions/API Routes that manage the agent flow.                                                                                               |

---

**Integrated AI Agent Tool Strategy Summary:**

1.  **Define Securely:** Create tools server-side using **AI SDK** `tool()`. Define parameters precisely (**Zod/Valibot**, maybe from **Drizzle**). Implement secure `execute` functions for backend actions (DB, APIs). Omit `execute` for client interactions.
2.  **Orchestrate Server-Side:** Use **Next.js Server Actions/Routes** to run agent logic. Employ **AI SDK** `streamText` with `maxSteps` to manage the LLM -> Tool -> LLM loop. Guide the LLM with clear prompts and `toolChoice` when needed.
3.  **Execute Efficiently:** Optimize server-side `execute` functions: use fast, indexed **Drizzle** queries; cache results in **Redis**; handle errors robustly. For client-side tools, use **React** `useChat`'s `onToolCall` hook for automation or render UI for confirmation, using `addToolResult` to send outcomes back.
4.  **Stream for Responsiveness:** Use `streamText` server-side and `useChat` client-side. Render text incrementally. Display clear agent status and tool invocation states (`call`, `result`). Consider `toolCallStreaming` for faster feedback on tool usage.
5.  **Validate & Authorize Rigorously:** Validate tool arguments using schemas server-side. Re-check user authentication/authorization inside every sensitive `execute` function. Rely on **Supabase RLS** as a secondary security layer.
6.  **Monitor & Test:** Trace agent flows using **AI SDK Telemetry**. Monitor tool execution times and error rates. Write tests for individual tools and mock LLM/tool interactions to test the overall orchestration logic.

By focusing on these tool-centric best practices, you can build powerful, reliable, and performant AI agents that effectively leverage the capabilities of your entire tech stack.